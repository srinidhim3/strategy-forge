"""
Trading Strategy Framework for Strategy Forge

This module implements various trading strategies that generate buy/sell signals
based on fundamental and technical analysis indicators. All strategies integrate
seamlessly with the DataProcessingPipeline for end-to-end workflow.

Key Components:
- BaseStrategy: Abstract base class defining strategy interface
- PEThresholdStrategy: Fundamental strategy based on P/E ratio thresholds
- MovingAverageStrategy: Technical strategy using moving average crossovers
- CombinedStrategy: Multi-factor strategy combining fundamental and technical signals

Author: Strategy Forge Development Team
Version: 1.0
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import Dict, List, Optional, Union, Tuple
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import logging

# Setup logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


@dataclass
class StrategyConfig:
    """Configuration container for strategy parameters"""
    name: str
    description: str
    parameters: Dict
    start_date: Optional[str] = None
    end_date: Optional[str] = None
    initial_capital: float = 100000.0
    transaction_cost: float = 0.001  # 0.1% transaction cost
    min_position_size: float = 0.01  # Minimum 1% position
    max_position_size: float = 1.0   # Maximum 100% position


@dataclass
class TradingSignal:
    """Represents a trading signal generated by a strategy"""
    date: str
    signal: str  # 'BUY', 'SELL', 'HOLD'
    strength: float  # Signal strength 0-1
    price: float
    rationale: str
    metadata: Dict = None


class BaseStrategy(ABC):
    """
    Abstract base class for all trading strategies
    
    Provides common interface and functionality for strategy implementation.
    All strategies must implement generate_signals() method.
    """
    
    def __init__(self, config: StrategyConfig):
        self.config = config
        self.name = config.name
        self.signals = []
        self.data = None
        self.performance_metrics = {}
        
        # Validate configuration
        self.validate_config()
        
        logger.info(f"Initialized strategy: {self.name}")
    
    @abstractmethod
    def generate_signals(self, data: pd.DataFrame) -> List[TradingSignal]:
        """
        Generate trading signals from processed data
        
        Args:
            data: DataFrame with aligned price and fundamental data
            
        Returns:
            List of TradingSignal objects
        """
        pass
    
    def validate_config(self) -> bool:
        """Validate strategy configuration parameters"""
        required_fields = ['name', 'description', 'parameters']
        for field in required_fields:
            if not hasattr(self.config, field):
                raise ValueError(f"Missing required config field: {field}")
        
        if self.config.initial_capital <= 0:
            raise ValueError("Initial capital must be positive")
        
        if not (0 <= self.config.transaction_cost <= 1):
            raise ValueError("Transaction cost must be between 0 and 1")
        
        return True
    
    def calculate_positions(self, signals: List[TradingSignal]) -> pd.DataFrame:
        """
        Convert trading signals to position sizes
        
        Args:
            signals: List of trading signals
            
        Returns:
            DataFrame with dates, signals, and position sizes
        """
        if not signals:
            return pd.DataFrame()
        
        positions = []
        current_position = 0.0
        
        for signal in signals:
            if signal.signal == 'BUY':
                # Calculate position size based on signal strength
                target_position = min(
                    signal.strength * self.config.max_position_size,
                    self.config.max_position_size
                )
                target_position = max(target_position, self.config.min_position_size)
            elif signal.signal == 'SELL':
                target_position = 0.0
            else:  # HOLD
                target_position = current_position
            
            positions.append({
                'date': signal.date,
                'signal': signal.signal,
                'price': signal.price,
                'position': target_position,
                'position_change': target_position - current_position,
                'signal_strength': signal.strength,
                'rationale': signal.rationale
            })
            
            current_position = target_position
        
        return pd.DataFrame(positions)
    
    def get_summary(self) -> Dict:
        """Get strategy summary and configuration"""
        return {
            'name': self.name,
            'description': self.config.description,
            'parameters': self.config.parameters,
            'signal_count': len(self.signals),
            'performance_metrics': self.performance_metrics
        }


class PEThresholdStrategy(BaseStrategy):
    """
    P/E Ratio Threshold Strategy
    
    Generates buy signals when P/E ratio falls below threshold (undervalued)
    and sell signals when P/E ratio exceeds threshold (overvalued).
    
    Parameters:
    - buy_pe_threshold: P/E threshold for buy signals (default: 15)
    - sell_pe_threshold: P/E threshold for sell signals (default: 25)
    - min_pe: Minimum P/E to consider (filters out negative/extreme values)
    - max_pe: Maximum P/E to consider (filters out extreme values)
    """
    
    def __init__(self, config: StrategyConfig):
        # Set default parameters if not provided
        default_params = {
            'buy_pe_threshold': 15.0,
            'sell_pe_threshold': 25.0,
            'min_pe': 5.0,
            'max_pe': 50.0
        }
        
        # Merge with user parameters
        for key, value in default_params.items():
            if key not in config.parameters:
                config.parameters[key] = value
        
        super().__init__(config)
        
        # Validate P/E specific parameters
        self._validate_pe_parameters()
    
    def _validate_pe_parameters(self):
        """Validate P/E strategy specific parameters"""
        params = self.config.parameters
        
        if params['buy_pe_threshold'] <= 0:
            raise ValueError("Buy P/E threshold must be positive")
        
        if params['sell_pe_threshold'] <= params['buy_pe_threshold']:
            raise ValueError("Sell P/E threshold must be greater than buy threshold")
        
        if params['min_pe'] <= 0 or params['max_pe'] <= params['min_pe']:
            raise ValueError("Invalid P/E range: min_pe < max_pe and both positive")
    
    def generate_signals(self, data: pd.DataFrame) -> List[TradingSignal]:
        """
        Generate signals based on P/E ratio thresholds
        
        Logic:
        - BUY when P/E drops below buy_threshold (undervalued)
        - SELL when P/E rises above sell_threshold (overvalued)
        - HOLD otherwise
        """
        self.data = data.copy()
        signals = []
        
        if 'pe_ratio' not in data.columns:
            logger.error("P/E ratio not found in data. Ensure DataProcessingPipeline includes ratio calculations.")
            return signals
        
        params = self.config.parameters
        buy_threshold = params['buy_pe_threshold']
        sell_threshold = params['sell_pe_threshold']
        min_pe = params['min_pe']
        max_pe = params['max_pe']
        
        # Filter data for valid P/E ratios
        valid_data = data[
            (data['pe_ratio'].notna()) & 
            (data['pe_ratio'] >= min_pe) & 
            (data['pe_ratio'] <= max_pe)
        ].copy()
        
        if valid_data.empty:
            logger.warning("No valid P/E data found for signal generation")
            return signals
        
        logger.info(f"Generating P/E signals for {len(valid_data)} data points")
        logger.info(f"P/E range: {valid_data['pe_ratio'].min():.2f} - {valid_data['pe_ratio'].max():.2f}")
        
        previous_signal = 'HOLD'
        
        for idx, row in valid_data.iterrows():
            pe_ratio = row['pe_ratio']
            price = row['close']
            date = row.name if isinstance(row.name, str) else str(row.name)
            
            # Determine signal
            if pe_ratio <= buy_threshold and previous_signal != 'BUY':
                signal_type = 'BUY'
                # Signal strength based on how far below threshold
                strength = min(1.0, (buy_threshold - pe_ratio) / buy_threshold + 0.1)
                rationale = f"P/E {pe_ratio:.2f} below buy threshold {buy_threshold}"
                
            elif pe_ratio >= sell_threshold and previous_signal != 'SELL':
                signal_type = 'SELL'
                # Signal strength based on how far above threshold
                strength = min(1.0, (pe_ratio - sell_threshold) / sell_threshold + 0.1)
                rationale = f"P/E {pe_ratio:.2f} above sell threshold {sell_threshold}"
                
            else:
                signal_type = 'HOLD'
                strength = 0.0
                rationale = f"P/E {pe_ratio:.2f} in neutral range [{buy_threshold}, {sell_threshold}]"
            
            # Only add signal if it's different from previous (avoid redundant signals)
            if signal_type != previous_signal or signal_type == 'HOLD':
                signal = TradingSignal(
                    date=date,
                    signal=signal_type,
                    strength=strength,
                    price=price,
                    rationale=rationale,
                    metadata={'pe_ratio': pe_ratio}
                )
                signals.append(signal)
                previous_signal = signal_type
        
        self.signals = signals
        logger.info(f"Generated {len(signals)} P/E threshold signals")
        
        # Calculate signal statistics
        buy_signals = [s for s in signals if s.signal == 'BUY']
        sell_signals = [s for s in signals if s.signal == 'SELL']
        
        self.performance_metrics.update({
            'total_signals': len(signals),
            'buy_signals': len(buy_signals),
            'sell_signals': len(sell_signals),
            'avg_buy_pe': np.mean([s.metadata['pe_ratio'] for s in buy_signals]) if buy_signals else 0,
            'avg_sell_pe': np.mean([s.metadata['pe_ratio'] for s in sell_signals]) if sell_signals else 0
        })
        
        return signals


class MovingAverageStrategy(BaseStrategy):
    """
    Moving Average Crossover Strategy
    
    Generates signals based on moving average crossovers:
    - BUY when short MA crosses above long MA (bullish crossover)
    - SELL when short MA crosses below long MA (bearish crossover)
    
    Supports both Simple Moving Average (SMA) and Exponential Moving Average (EMA)
    
    Parameters:
    - short_window: Short moving average period (default: 20)
    - long_window: Long moving average period (default: 50)
    - ma_type: 'SMA' or 'EMA' (default: 'SMA')
    - price_column: Column to use for MA calculation (default: 'close')
    """
    
    def __init__(self, config: StrategyConfig):
        # Set default parameters
        default_params = {
            'short_window': 20,
            'long_window': 50,
            'ma_type': 'SMA',
            'price_column': 'close'
        }
        
        for key, value in default_params.items():
            if key not in config.parameters:
                config.parameters[key] = value
        
        super().__init__(config)
        self._validate_ma_parameters()
    
    def _validate_ma_parameters(self):
        """Validate moving average parameters"""
        params = self.config.parameters
        
        if params['short_window'] <= 0 or params['long_window'] <= 0:
            raise ValueError("Moving average windows must be positive")
        
        if params['short_window'] >= params['long_window']:
            raise ValueError("Short window must be less than long window")
        
        if params['ma_type'] not in ['SMA', 'EMA']:
            raise ValueError("ma_type must be 'SMA' or 'EMA'")
    
    def _calculate_moving_averages(self, data: pd.DataFrame) -> pd.DataFrame:
        """Calculate moving averages for the price data"""
        params = self.config.parameters
        short_window = params['short_window']
        long_window = params['long_window']
        ma_type = params['ma_type']
        price_col = params['price_column']
        
        if price_col not in data.columns:
            raise ValueError(f"Price column '{price_col}' not found in data")
        
        data = data.copy()
        
        if ma_type == 'SMA':
            data[f'ma_short'] = data[price_col].rolling(window=short_window).mean()
            data[f'ma_long'] = data[price_col].rolling(window=long_window).mean()
        else:  # EMA
            data[f'ma_short'] = data[price_col].ewm(span=short_window).mean()
            data[f'ma_long'] = data[price_col].ewm(span=long_window).mean()
        
        return data
    
    def generate_signals(self, data: pd.DataFrame) -> List[TradingSignal]:
        """
        Generate signals based on moving average crossovers
        """
        self.data = data.copy()
        signals = []
        
        # Calculate moving averages
        try:
            ma_data = self._calculate_moving_averages(data)
        except ValueError as e:
            logger.error(f"Error calculating moving averages: {e}")
            return signals
        
        # Remove NaN values (insufficient data for long MA)
        params = self.config.parameters
        long_window = params['long_window']
        valid_data = ma_data.dropna().copy()
        
        if len(valid_data) < 2:
            logger.warning("Insufficient data for moving average crossover signals")
            return signals
        
        logger.info(f"Generating MA crossover signals for {len(valid_data)} data points")
        logger.info(f"MA parameters: {params['short_window']}-period vs {params['long_window']}-period {params['ma_type']}")
        
        previous_signal = 'HOLD'
        
        for i in range(1, len(valid_data)):
            current_row = valid_data.iloc[i]
            previous_row = valid_data.iloc[i-1]
            
            price = current_row['close']
            date = current_row.name if isinstance(current_row.name, str) else str(current_row.name)
            
            short_ma_curr = current_row['ma_short']
            long_ma_curr = current_row['ma_long']
            short_ma_prev = previous_row['ma_short']
            long_ma_prev = previous_row['ma_long']
            
            # Detect crossovers
            bullish_crossover = (short_ma_prev <= long_ma_prev) and (short_ma_curr > long_ma_curr)
            bearish_crossover = (short_ma_prev >= long_ma_prev) and (short_ma_curr < long_ma_curr)
            
            if bullish_crossover and previous_signal != 'BUY':
                signal_type = 'BUY'
                # Signal strength based on the magnitude of crossover
                crossover_magnitude = (short_ma_curr - long_ma_curr) / long_ma_curr
                strength = min(1.0, abs(crossover_magnitude) * 10 + 0.2)
                rationale = f"Bullish crossover: {params['short_window']}-MA ({short_ma_curr:.2f}) > {params['long_window']}-MA ({long_ma_curr:.2f})"
                
            elif bearish_crossover and previous_signal != 'SELL':
                signal_type = 'SELL'
                crossover_magnitude = (long_ma_curr - short_ma_curr) / long_ma_curr
                strength = min(1.0, abs(crossover_magnitude) * 10 + 0.2)
                rationale = f"Bearish crossover: {params['short_window']}-MA ({short_ma_curr:.2f}) < {params['long_window']}-MA ({long_ma_curr:.2f})"
                
            else:
                # Determine trend strength for HOLD signals
                if short_ma_curr > long_ma_curr:
                    signal_type = 'HOLD'
                    strength = 0.0
                    rationale = f"Bullish trend: {params['short_window']}-MA above {params['long_window']}-MA"
                else:
                    signal_type = 'HOLD'
                    strength = 0.0
                    rationale = f"Bearish trend: {params['short_window']}-MA below {params['long_window']}-MA"
            
            # Add signal if it's a crossover or first signal
            if signal_type != previous_signal or len(signals) == 0:
                signal = TradingSignal(
                    date=date,
                    signal=signal_type,
                    strength=strength,
                    price=price,
                    rationale=rationale,
                    metadata={
                        'short_ma': short_ma_curr,
                        'long_ma': long_ma_curr,
                        'ma_spread': short_ma_curr - long_ma_curr
                    }
                )
                signals.append(signal)
                previous_signal = signal_type
        
        self.signals = signals
        logger.info(f"Generated {len(signals)} moving average crossover signals")
        
        # Calculate performance metrics
        buy_signals = [s for s in signals if s.signal == 'BUY']
        sell_signals = [s for s in signals if s.signal == 'SELL']
        
        self.performance_metrics.update({
            'total_signals': len(signals),
            'buy_signals': len(buy_signals),
            'sell_signals': len(sell_signals),
            'crossover_signals': len(buy_signals) + len(sell_signals),
            'avg_signal_strength': np.mean([s.strength for s in signals if s.strength > 0]) if signals else 0
        })
        
        return signals


class CombinedStrategy(BaseStrategy):
    """
    Combined Multi-Factor Strategy
    
    Combines fundamental and technical analysis by integrating:
    - P/E ratio thresholds (fundamental)
    - Moving average crossovers (technical)
    
    Signal generation logic:
    - STRONG BUY: Both fundamental and technical signals are bullish
    - BUY: One signal is bullish, other is neutral
    - SELL: One or both signals are bearish
    - HOLD: All signals are neutral
    
    Parameters:
    - Includes all parameters from PEThresholdStrategy and MovingAverageStrategy
    - weight_fundamental: Weight for fundamental signals (0-1, default: 0.6)
    - weight_technical: Weight for technical signals (0-1, default: 0.4)
    - min_signal_strength: Minimum combined strength to generate signal (default: 0.3)
    """
    
    def __init__(self, config: StrategyConfig):
        # Set default weights
        default_params = {
            'weight_fundamental': 0.6,
            'weight_technical': 0.4,
            'min_signal_strength': 0.3,
            # P/E strategy defaults
            'buy_pe_threshold': 15.0,
            'sell_pe_threshold': 25.0,
            'min_pe': 5.0,
            'max_pe': 50.0,
            # MA strategy defaults
            'short_window': 20,
            'long_window': 50,
            'ma_type': 'SMA',
            'price_column': 'close'
        }
        
        for key, value in default_params.items():
            if key not in config.parameters:
                config.parameters[key] = value
        
        super().__init__(config)
        
        # Initialize sub-strategies
        pe_config = StrategyConfig(
            name=f"{config.name}_PE",
            description="P/E component of combined strategy",
            parameters={k: v for k, v in config.parameters.items() 
                       if k in ['buy_pe_threshold', 'sell_pe_threshold', 'min_pe', 'max_pe']}
        )
        
        ma_config = StrategyConfig(
            name=f"{config.name}_MA",
            description="MA component of combined strategy", 
            parameters={k: v for k, v in config.parameters.items()
                       if k in ['short_window', 'long_window', 'ma_type', 'price_column']}
        )
        
        self.pe_strategy = PEThresholdStrategy(pe_config)
        self.ma_strategy = MovingAverageStrategy(ma_config)
        
        self._validate_combined_parameters()
    
    def _validate_combined_parameters(self):
        """Validate combined strategy parameters"""
        params = self.config.parameters
        
        if not (0 <= params['weight_fundamental'] <= 1):
            raise ValueError("weight_fundamental must be between 0 and 1")
        
        if not (0 <= params['weight_technical'] <= 1):
            raise ValueError("weight_technical must be between 0 and 1")
        
        if abs(params['weight_fundamental'] + params['weight_technical'] - 1.0) > 0.01:
            raise ValueError("Fundamental and technical weights must sum to 1.0")
        
        if not (0 <= params['min_signal_strength'] <= 1):
            raise ValueError("min_signal_strength must be between 0 and 1")
    
    def generate_signals(self, data: pd.DataFrame) -> List[TradingSignal]:
        """
        Generate combined signals from fundamental and technical analysis
        """
        self.data = data.copy()
        signals = []
        
        # Generate signals from sub-strategies
        pe_signals = self.pe_strategy.generate_signals(data)
        ma_signals = self.ma_strategy.generate_signals(data)
        
        if not pe_signals and not ma_signals:
            logger.warning("No signals generated from sub-strategies")
            return signals
        
        # Create signal dictionaries for easy lookup
        pe_signal_dict = {s.date: s for s in pe_signals}
        ma_signal_dict = {s.date: s for s in ma_signals}
        
        # Get all unique dates
        all_dates = sorted(set(list(pe_signal_dict.keys()) + list(ma_signal_dict.keys())))
        
        params = self.config.parameters
        weight_fund = params['weight_fundamental']
        weight_tech = params['weight_technical']
        min_strength = params['min_signal_strength']
        
        logger.info(f"Combining signals from {len(all_dates)} dates")
        logger.info(f"Weights: Fundamental {weight_fund:.1%}, Technical {weight_tech:.1%}")
        
        previous_signal = 'HOLD'
        
        for date in all_dates:
            pe_signal = pe_signal_dict.get(date)
            ma_signal = ma_signal_dict.get(date)
            
            # Get price from available signal
            price = pe_signal.price if pe_signal else ma_signal.price
            
            # Calculate combined signal strength
            fund_score = 0.0
            tech_score = 0.0
            rationale_parts = []
            metadata = {}
            
            if pe_signal:
                if pe_signal.signal == 'BUY':
                    fund_score = pe_signal.strength
                elif pe_signal.signal == 'SELL':
                    fund_score = -pe_signal.strength
                
                rationale_parts.append(f"P/E: {pe_signal.rationale}")
                metadata.update(pe_signal.metadata or {})
            
            if ma_signal:
                if ma_signal.signal == 'BUY':
                    tech_score = ma_signal.strength
                elif ma_signal.signal == 'SELL':
                    tech_score = -ma_signal.strength
                
                rationale_parts.append(f"MA: {ma_signal.rationale}")
                metadata.update(ma_signal.metadata or {})
            
            # Calculate weighted combined score
            combined_score = weight_fund * fund_score + weight_tech * tech_score
            combined_strength = abs(combined_score)
            
            # Determine signal type
            if combined_score > min_strength:
                signal_type = 'BUY'
                strength = combined_strength
            elif combined_score < -min_strength:
                signal_type = 'SELL'
                strength = combined_strength
            else:
                signal_type = 'HOLD'
                strength = 0.0
            
            # Only add signal if different from previous
            if signal_type != previous_signal:
                rationale = "; ".join(rationale_parts)
                rationale += f" | Combined score: {combined_score:.3f}"
                
                signal = TradingSignal(
                    date=date,
                    signal=signal_type,
                    strength=strength,
                    price=price,
                    rationale=rationale,
                    metadata={
                        **metadata,
                        'fund_score': fund_score,
                        'tech_score': tech_score,
                        'combined_score': combined_score
                    }
                )
                signals.append(signal)
                previous_signal = signal_type
        
        self.signals = signals
        logger.info(f"Generated {len(signals)} combined strategy signals")
        
        # Aggregate performance metrics
        buy_signals = [s for s in signals if s.signal == 'BUY']
        sell_signals = [s for s in signals if s.signal == 'SELL']
        
        self.performance_metrics.update({
            'total_signals': len(signals),
            'buy_signals': len(buy_signals),
            'sell_signals': len(sell_signals),
            'avg_combined_strength': np.mean([s.strength for s in signals if s.strength > 0]) if signals else 0,
            'pe_strategy_metrics': self.pe_strategy.performance_metrics,
            'ma_strategy_metrics': self.ma_strategy.performance_metrics
        })
        
        return signals


def create_strategy(strategy_type: str, config: StrategyConfig) -> BaseStrategy:
    """
    Factory function to create strategy instances
    
    Args:
        strategy_type: Type of strategy ('pe_threshold', 'moving_average', 'combined')
        config: Strategy configuration
        
    Returns:
        Instantiated strategy object
    """
    strategy_map = {
        'pe_threshold': PEThresholdStrategy,
        'moving_average': MovingAverageStrategy,
        'combined': CombinedStrategy
    }
    
    if strategy_type not in strategy_map:
        raise ValueError(f"Unknown strategy type: {strategy_type}. Available: {list(strategy_map.keys())}")
    
    return strategy_map[strategy_type](config)


if __name__ == "__main__":
    # Example usage
    print("Strategy Forge - Trading Strategy Framework")
    print("=========================================")
    
    # Example P/E threshold strategy configuration
    pe_config = StrategyConfig(
        name="Conservative P/E Strategy",
        description="Buy when P/E < 15, sell when P/E > 25",
        parameters={
            'buy_pe_threshold': 15.0,
            'sell_pe_threshold': 25.0,
            'min_pe': 5.0,
            'max_pe': 40.0
        }
    )
    
    # Example moving average strategy configuration
    ma_config = StrategyConfig(
        name="20/50 SMA Crossover",
        description="Buy on bullish crossover, sell on bearish crossover",
        parameters={
            'short_window': 20,
            'long_window': 50,
            'ma_type': 'SMA'
        }
    )
    
    # Example combined strategy configuration
    combined_config = StrategyConfig(
        name="Multi-Factor Strategy",
        description="Combines P/E and MA signals with 60/40 weighting",
        parameters={
            'weight_fundamental': 0.6,
            'weight_technical': 0.4,
            'min_signal_strength': 0.3,
            'buy_pe_threshold': 18.0,
            'sell_pe_threshold': 30.0,
            'short_window': 15,
            'long_window': 40
        }
    )
    
    # Create strategy instances
    pe_strategy = create_strategy('pe_threshold', pe_config)
    ma_strategy = create_strategy('moving_average', ma_config)
    combined_strategy = create_strategy('combined', combined_config)
    
    print(f"Created strategies:")
    print(f"- {pe_strategy.name}")
    print(f"- {ma_strategy.name}")
    print(f"- {combined_strategy.name}")
    
    print("\nStrategies ready for signal generation!")